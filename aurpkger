#!/usr/bin/sh
# 
# Install and manage AUR packages

alias echo='echo -e'

# Basic info about the program, easily changeable
readonly PROGRAM_NAME="$(basename $0)"
readonly COMPLETE_ARGS_LIST="$@"
readonly VERSION="0.0.9"

readonly program_cache="${HOME}/.cache/${PROGRAM_NAME}"
readonly aur_package_list="${program_cache}/package_list"

# Colours -- they make things easier to distinguish
readonly LIGHT_RED='\e[1;31m'
readonly BLUE='\e[1m\e[0;36m'
readonly RESET_CLR='\e[0m'
readonly BOLD='\e[1m'
readonly ERROR="${BOLD}${LIGHT_RED}error:${RESET_CLR}"
readonly WARNING="${LIGHT_RED}warning:${RESET_CLR}"

###
# Globals:
#   PROGRAM_NAME
# Arguments:
#   none
###
display_help_message() {
cat <<END_OF_HELP
Usage:  ${PROGRAM_NAME} <operation> [...]
Operations:
    ${PROGRAM_NAME} install   <package(s)>
END_OF_HELP
}

###
# Globals:
#   $program_cache
#   $aur_package_list
#   $ERROR
# Arguments:
#   none
###
initialization_and_sanitization() {
    if ! ping archlinux.org -c 1 &> /dev/null; then
        echo "${ERROR} https://archlinux.org is unreachable"
        exit 1
    fi

    [[ -d ${program_cache} ]] || mkdir ${program_cache}

    # Execute function in the background
    [[ -f ${aur_package_list} ]] || update_aur_package_list &
}

###
# Equivalent of pacman -Sy, aka sync with database
# Globals:
#   aur_package_list
# Arguments:
#   'v' (verbose) *or* none
# Returns:
#   If the verbose argument is given, gives status
#   Updated list of programs 
###
update_aur_package_list() {
    [[ $1 == "v" ]] && echo "==> Downloading list of AUR packages..."
    curl -o ${aur_package_list}.gz -L https://aur.archlinux.org/packages.gz &>/dev/null

    [[ $1 == "v" ]] && echo "==> Unzipping compressed file..."
    gunzip < ${aur_package_list}.gz > ${aur_package_list}

    [[ $1 == "v" ]] && echo "==> Removing compressed file..."
    rm -f ${aur_package_list}.gz

    [[ $1 == "v" ]] && echo "==> Removing comments from unzipped file..."
    sed '/^#/d' -i ${aur_package_list}
}

###
# Effectively, perform something like pacman -Ss on arguemnts
# Globals:
#   aur_package_list
#   BLUE
#   RESET_CLR
#   BOLD
# Arguments:
#   Package(s) to search for
# Returns:
#   Displays results
###
search_packages_in_aur() {
    declare results=$(grep "$@" ${aur_package_list})

    while IFS= read -r pkg; do
        echo "${BLUE}aur/${RESET_CLR}${BOLD}${pkg}${RESET_CLR}"
    done <<< "${results}"

    return 0
}

###
# Somewhat like pacman -S
# Globals:
#   aur_package_list
#   ERROR
#   WARNING
#   BOLD
#   RESET_CLR
#   program_cache
# Arguments:
#   pkg (package to install)
# Returns:
#   0 on success, exits with 1 otherwise
###
install_aur_package() {
    declare -r pkg=$1
    declare -r install_location=${program_cache}/${pkg}

    if ! grep -w "^${pkg}$" ${aur_package_list} &> /dev/null; then
        if ! pacman -Si ${pkg} &>/dev/null; then
            echo "${ERROR} package does not exist in aur, nor official
            repositories"
            exit 1
        else
            echo "${WARNING} package not found in aur, but found in official" \
                "repositories.\n"
            echo -n "${BOLD}>> Install from official repositories?${RESET_CLR} "
            echo -En '[Y\n] '
            read ans
            case $ans in
                n|N) 
                    echo "\n---> User declined to install; exiting..."
                    exit 1
                    ;;
                *) 
                    sudo pacman -S ${pkg}
                    ;;
            esac
        fi
    fi

    # Abort installation if user kills process
    trap "rm -rf ${install_location}; echo \"\n\n${ERROR} aborted by user; exiting...\";
    exit 1" SIGTERM SIGINT SIGHUP


    echo "---> Downloading package '${pkg}'...\n"
    git clone https://aur.archlinux.org/${pkg}.git ${install_location} &>/dev/null

    cd ${install_location}


    echo -n "${BOLD}>>> Read PKGBUILD?${RESET_CLR} "
    echo -En '[Y\n] '
    read ans
    case ${ans} in
        n|N)
            ;;
        *)
            ${PAGER} ./PKGBUILD
    esac


    echo -n ">${BOLD}>> Build package?${RESET_CLR} "
    echo -En '[Y\n] '
    read ans
    case ${ans} in
        n|N)
            echo "\n---> User declined to install; cleaning up..."
            rm -rf ${install_location}
            ;;
        *)
            # This actually runs the command, and then checks the exit code
            # (confusingly, it only accepts '0', which is 'success')
            if makepkg --install --syncdeps --rmdeps; then
                echo "\n---> '${pkg}' was successfully installed"
            else
                echo "\n---> Package not successfully installed; cleaning up..."
                rm -rf ${install_location}
            fi
    esac

    # Change directory back, or else git will give a "fatal: unable to read
    # current working directory" error
    cd

    return 0
}

###
# Globals:
#   ERROR
#   WARNING
#   program_cache
# Arguments:
#   Package to remove
# Returns:
#   0 on success, exits otherwise
###
remove_aur_package() {
    declare -r pkg=$1

    if ! pacman -Q ${pkg} &> /dev/null; then
        echo "${ERROR} package is not installed on system"
        exit 1
    fi

    if [[ ! -d ${program_cache}/${pkg} ]]; then
        echo "${WARNING} package is not in ${program_cache}"
    else 
        echo "---> Removing ${program_cache}/${pkg}..."
        rm -rf ${program_cache}/${pkg}
    fi
    
    sudo pacman -Rns ${pkg}

    return 0
}

###
# Control the program
# Globals:
#   VERSION
#   ERROR
#   WARNING
# Arguments:
#   Everything passed to the script
# Returns:
#   0 if success, 1 otherwise
###
main() {
    initialization_and_sanitization &

    declare operation=$1

    # Process options
    case ${operation} in
        -h )
            display_help_message
            ;;

        -v )
            echo "Version: ${VERSION}"
            ;;

        install )
            shift # remove subcommand
            declare pkgs=$@
            
            # Error checking
            if [[ -z ${pkgs} ]]; then 
                echo "${ERROR} no package specified" &&
                exit 1
            else
                shift
            fi

            for pkg in ${pkgs}; do
                install_aur_package ${pkg}
            done
            ;;

        search )
            shift # remove subcommand
            declare pkgs=$@

            # Error checking 
            if [[ -z ${pkgs} ]]; then 
                echo "${ERROR} no package specified" &&
                exit 1
            else
                shift
            fi
            search_packages_in_aur ${pkgs}
            ;;

        update )
            shift
            if [[ ! -z $1 ]]; then
                echo "${WARNING} the 'update' operation takes no arguments"
            fi

            update_aur_package_list "v"
            ;;

        remove ) 
            shift
            declare pkgs=$@

            # More error checking...
            if [[ -z ${pkgs} ]]; then
                echo "${ERROR} no package specified" &&
                exit 1
            else 
                shift
            fi

            for pkg in ${pkgs}; do
                remove_aur_package ${pkg}
            done
            ;;

        * )
            echo "${ERROR} no operation specified (use -h for help)"
            exit 1
            ;;
    esac

    exit 0
}

main $COMPLETE_ARGS_LIST
