#!/usr/bin/sh

# Install and manage AUR packages

alias echo='echo -e'

# Basic info about the program, easily changeable
readonly PROGRAM_NAME="$(basename $0)"
readonly VERSION="0.1.0"

readonly program_cache="${HOME}/.cache/${PROGRAM_NAME}"
readonly aur_package_list="${program_cache}/package_list"

# Colours -- they make things easier to distinguish
readonly LIGHT_RED='\e[1;31m'
readonly BLUE='\e[1m\e[0;36m'
readonly RESET_CLR='\e[0m'
readonly BOLD='\e[1m'
readonly ERROR="${BOLD}${LIGHT_RED}error:${RESET_CLR}"
readonly WARNING="${LIGHT_RED}warning:${RESET_CLR}"

###
# Globals:
#   PROGRAM_NAME
# Arguments:
#   none
###
display_help_message() {
cat <<END_OF_HELP
${PROGRAM_NAME} version ${VERSION}
Usage:  ${PROGRAM_NAME} <operation> [...]
Operations:
    ${PROGRAM_NAME} -h
    ${PROGRAM_NAME} install   <package(s)>
    ${PROGRAM_NAME} remove    <package(s)>
    ${PROGRAM_NAME} search
    ${PROGRAM_NAME} update-aur-package-list
END_OF_HELP
}

###
# Globals:
#   $program_cache
#   $aur_package_list
#   $ERROR
# Arguments:
#   none
###
initialization_and_sanitization() {
    if ! ping archlinux.org -c 1 &> /dev/null; then
        echo "${ERROR} https://archlinux.org is unreachable"
        exit 1
    fi

    [[ -d ${program_cache} ]] || mkdir ${program_cache}
    [[ -f ${aur_package_list} ]] || update_aur_package_list &
}

###
# Equivalent of pacman -Sy, aka sync with database
# Globals:
#   aur_package_list
# Arguments:
#   optionally, 'v' (verbose)
# Returns:
#   0 on success
###
update_aur_package_list() {
    [[ $1 == "v" ]] && echo "==> Downloading list of AUR packages..."
    curl -o ${aur_package_list}.gz -L https://aur.archlinux.org/packages.gz &>/dev/null

    [[ $1 == "v" ]] && echo "==> Unzipping compressed file..."
    gunzip < ${aur_package_list}.gz > ${aur_package_list}

    [[ $1 == "v" ]] && echo "==> Removing compressed file..."
    rm -f ${aur_package_list}.gz

    [[ $1 == "v" ]] && echo "==> Removing comments from unzipped file..."
    sed '/^#/d' -i ${aur_package_list}

    return 0
}

###
# Effectively, perform something like pacman -Ss on arguemnts
# Globals:
#   aur_package_list
#   BLUE
#   RESET_CLR
#   BOLD
# Arguments:
#   Package(s) to search for
# Returns:
#   0 on success, exits with 1 otherwise
###
search_packages_in_aur() {
    declare results=$(grep "$@" ${aur_package_list})

    if [[ ! -z ${results} ]]; then
        while IFS= read -r pkg; do
            echo "${BLUE}aur/${RESET_CLR}${BOLD}${pkg}${RESET_CLR}"
        done <<< "${results}"
        return 0
    else 
        return 1
    fi
}

###
# Basically pacman -S
# Globals:
#   aur_package_list
#   ERROR
#   WARNING
#   BOLD
#   RESET_CLR
#   program_cache
# Arguments:
#   pkg (package to install)
# Returns:
#   0 on success, exits with 1 otherwise
###
install_aur_package() {
    declare -r pkg=$1
    declare -r install_location=${program_cache}/${pkg}

    if ! grep -w "^${pkg}$" ${aur_package_list} &> /dev/null; then
        if ! pacman -Si ${pkg} &>/dev/null; then
            echo "${ERROR} package does not exist in aur, nor official" \
            "repositories"
            exit 1
        else
            echo "${WARNING} package '${pkg}' not found in aur, but found in official" \
                "repositories.\n"
            echo -n "${BOLD}>> Install from official repositories?${RESET_CLR} "
            echo -En '[Y\n] '
            read ans
            case $ans in
                n|N) 
                    echo "\n---> User declined to install; exiting..."
                    exit 1
                    ;;
                *) 
                    sudo pacman -S ${pkg}
                    ;;
            esac
        fi
    fi

    trap "rm -rf ${install_location}; echo \"\n\n${ERROR} aborted by user; exiting...\";
    exit 1" SIGTERM SIGINT SIGHUP

    echo "---> Downloading package '${pkg}'...\n"
    git clone https://aur.archlinux.org/${pkg}.git ${install_location} &>/dev/null

    cd ${install_location}

    echo -n "${BOLD}>>> Read PKGBUILD?${RESET_CLR} "
    echo -En '[Y\n] '
    read ans
    case ${ans} in
        n|N)
            ;;
        *)
            ${PAGER} ./PKGBUILD
    esac

    echo -n ">${BOLD}>> Build package?${RESET_CLR} "
    echo -En '[Y\n] '
    read ans
    case ${ans} in
        n|N)
            echo "\n---> User declined to install; cleaning up..."
            rm -rf ${install_location}
            ;;
        *)
            if makepkg --install --syncdeps --rmdeps; then
                echo "\n---> '${pkg}' was successfully installed"
            else
                echo "\n---> Package not successfully installed; cleaning up..."
                rm -rf ${install_location}
            fi
    esac

    # Change directory back, or else git will give a "fatal: unable to read
    # current working directory" error when installing multiple packages
    cd

    return 0
}

###
# Globals:
#   ERROR
#   WARNING
#   program_cache
# Arguments:
#   Package to remove
# Returns:
#   0 on success, exits otherwise
###
remove_aur_package() {
    declare -r pkg=$1

    if sudo pacman -Rns ${pkg} && [[ -d ${program_cache}/${pkg} ]]; then
        echo "---> Removing ${program_cache}/${pkg}..."
        rm -rf ${program_cache}/${pkg}
    fi

    return 0
}

###
# Control the program
# Globals:
#   VERSION
#   ERROR
#   WARNING
# Arguments:
#   Everything passed to the script
# Returns:
#   0 on success, 1 otherwise
###
main() {
    initialization_and_sanitization &

    declare operation=$1

    # Process options
    case ${operation} in
        -h)
            display_help_message
            ;;

        install)
            shift
            declare pkgs=$@

            if [[ -z ${pkgs} ]]; then 
                echo "${ERROR} no package specified" &&
                return 1
            fi
            shift

            for pkg in ${pkgs}; do
                install_aur_package ${pkg}
            done
            ;;

        search)
            shift # remove subcommand
            declare pkgs=$@

            if [[ -z ${pkgs} ]]; then 
                echo "${ERROR} no package specified" &&
                return 1
            fi
            shift

            search_packages_in_aur ${pkgs}
            ;;

        update-aur-package-list)
            shift
            if [[ ! -z $1 ]]; then
                echo "${WARNING} the 'update' operation takes no arguments"
            fi

            update_aur_package_list "v"
            ;;

        remove) 
            shift
            declare pkgs=$@

            if [[ -z ${pkgs} ]]; then
                echo "${ERROR} no package specified" &&
                return 1
            fi
            shift

            for pkg in ${pkgs}; do
                remove_aur_package ${pkg}
            done
            ;;

        *)
            echo "${ERROR} no operation specified (use -h or -H for help)"
            return 1
            ;;
    esac

    return 0
}

main $@
